#include "Mask.h"

#include <cstring>

Mask::Mask()
{
    bitMask = nullptr;
    width = height = 0;
}

Mask::Mask(const Mask& mask, const Rect& rect)
{
    width = rect.getWidth();
    height = rect.getHeight();
    bitMask = new bool[width * height];
    memset(bitMask,false,sizeof(bool)*width * height);

    for (int y = rect.getY() ; (y < rect.getHeight() && (y - rect.getY() < height && y  - rect.getY()> 0)); y++)
        for (int x = rect.getX() ; (x < rect.getWidth() && x < width && x > 0); x++)
            bitMask[(y - rect.getY())*width + (x - rect.getX())] = mask.bitMask[y*mask.width + x];
}

Mask::Mask(ALLEGRO_BITMAP* bitmap)
{
    width = al_get_bitmap_width(bitmap);
    height = al_get_bitmap_height(bitmap);
    bitMask = new bool[ width * height ];

    al_lock_bitmap(bitmap,al_get_bitmap_format(bitmap),ALLEGRO_LOCK_READONLY);

    for (int y = 0 ; y < height ; y++)
        for (int x = 0 ; x < width ; x++)
        {
            unsigned char r,g,b,a;
            al_unmap_rgba(al_get_pixel(bitmap, x, y),&r,&g,&b,&a);
            bitMask[y*width + x] = (a != 0);
        }

    al_unlock_bitmap(bitmap);
}

Mask::Mask(const Mask& mask)
{
    this->width = mask.width;
    this->height = mask.height;

    if (mask.bitMask == nullptr)
        this->bitMask = nullptr;
    else
    {
        this->bitMask = new bool[mask.width * mask.height];
        this->bitMask = (bool*)memcpy(this->bitMask,mask.bitMask,mask.width*mask.height * sizeof(bool));
    }
}

Mask &Mask::operator=(const Mask& mask)
{
    if (this == &mask)
        return *this;

    this->width = mask.width;
    this->height = mask.height;

    if (this->bitMask != nullptr)
        delete [] bitMask;

    if (mask.bitMask == nullptr)
        this->bitMask = nullptr;
    else
        {
            this->bitMask = new bool[mask.width * mask.height];
            this->bitMask = (bool*)memcpy(this->bitMask,mask.bitMask,mask.width*mask.height * sizeof(bool));
        }

    return *this;
}

Mask::~Mask()
{
    delete [] bitMask;
}

Mask Mask::getSubMask(const Rect& rect)
{
    Mask subMask(*this,rect);
    return subMask;
}

bool Mask::overlapWith(const Mask& mask) const
{
    for (int y = 0 ; (y < height && y < mask.height); y++)
        for (int x = 0 ; (x < width && x < mask.width); x++)
            if (bitMask[y*width + x] && mask.bitMask[y*mask.width + x])
                return true;

    return false;
}
